<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Mastering Linux Cross-Compilation for Embedded Systems</title>
<meta name=keywords content="Cross-compilation,Embedded Linux,Toolchain,Buildroot,Yocto,ARM SBC,Linux kernel,Device Tree"><meta name=description content="A comprehensive guide to cross-compiling Linux for embedded systems, covering toolchains, build systems, architecture-specific nuances, and practical examples."><meta name=author content="Embedded SBC Team"><link rel=canonical href=https://embedded-sbc.com/posts/linux-cross-compilation/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://embedded-sbc.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://embedded-sbc.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://embedded-sbc.com/favicon-32x32.png><link rel=apple-touch-icon href=https://embedded-sbc.com/apple-touch-icon.png><link rel=mask-icon href=https://embedded-sbc.com/safari-pinned-tab.svg><link rel=stylesheet href=/css/custom.css><meta name=google-site-verification content="Ildag3IJ8K9HbX7wkT_Z44Ct4zrjXoLNmZDGyD63wNo"><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://embedded-sbc.com/posts/linux-cross-compilation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://embedded-sbc.com/posts/linux-cross-compilation/"><meta property="og:site_name" content="Embedded SBC Blog"><meta property="og:title" content="Linux Cross-Compilation"><meta property="og:description" content="A comprehensive guide to cross-compiling Linux for embedded systems, covering toolchains, build systems, architecture-specific nuances, and practical examples."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-30T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux Cross-Compilation"><meta name=twitter:description content="A comprehensive guide to cross-compiling Linux for embedded systems, covering toolchains, build systems, architecture-specific nuances, and practical examples."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://embedded-sbc.com/posts/"},{"@type":"ListItem","position":2,"name":"Linux Cross-Compilation","item":"https://embedded-sbc.com/posts/linux-cross-compilation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux Cross-Compilation","name":"Linux Cross-Compilation","description":"A comprehensive guide to cross-compiling Linux for embedded systems, covering toolchains, build systems, architecture-specific nuances, and practical examples.","keywords":["Cross-compilation","Embedded Linux","Toolchain","Buildroot","Yocto","ARM SBC","Linux kernel","Device Tree"],"articleBody":"Cross-compilation is an essential skill for developers working on embedded systems. Unlike standard Linux development, where code is compiled and run on the same architecture, embedded systems often use different CPU architectures (e.g., ARM, RISC-V) than your development machine (typically x86_64). This guide provides a thorough overview of how cross-compilation works, why it matters, and how to set up your own environment for building Linux for embedded systems such as ARM-based single-board computers and other compact hardware platforms.\nWhat is Cross-Compilation? Cross-compilation is the process of building executable code for a target system that is different from the host system. For embedded systems, this usually means compiling code on an x86_64 PC that will run on an ARM or RISC-V device. This method is used because embedded systems often lack the resources to compile large projects locally.\nKey Concepts:\nHost: The system where the compilation is performed (e.g., Ubuntu x86_64) Target: The system where the compiled code will run (e.g., ARM Cortex-A SBC) Toolchain: A set of programs (compiler, linker, etc.) configured for a specific target Why Cross-Compile for Embedded Linux? There are several reasons why cross-compilation is necessary:\nResource Constraints: Embedded boardsâ€”like those in custom embedded system designsâ€”typically have limited CPU and RAM, making native compilation slow or impossible. Custom Kernels: Youâ€™ll often need to build custom Linux kernels or U-Boot versions specific to your board. Optimized Binaries: Cross-compilation allows building for performance-optimized targets using tailored compiler flags. Choosing the Right Toolchain Toolchains are central to cross-compilation. You can either:\nDownload pre-built toolchains (e.g., Linaro, GCC from Arm) Build your own toolchain using crosstool-NG Use BSP-provided toolchains that come with vendor SDKs (e.g., Rockchip, Allwinner) A popular prebuilt toolchain for ARM 32-bit:\nsudo apt install gcc-arm-linux-gnueabihf And for 64-bit ARM:\nsudo apt install gcc-aarch64-linux-gnu Anatomy of a Toolchain A complete toolchain contains:\ngcc â€“ The cross-compiler ld â€“ The linker as â€“ The assembler libc â€“ C standard library (often glibc or musl) binutils â€“ Binary utilities like objdump, strip, etc. Build Systems that Support Cross-Compilation There are many ways to manage a cross-compilation workflow. Here are a few popular tools:\n1. Makefiles Basic Makefiles allow cross-compiling by setting the compiler:\nCC=arm-linux-gnueabihf-gcc CFLAGS+=-march=armv7-a -mfpu=neon 2. CMake CMake supports toolchain files:\ncmake -DCMAKE_TOOLCHAIN_FILE=toolchain-arm.cmake . A basic toolchain-arm.cmake might look like:\nSET(CMAKE_SYSTEM_NAME Linux) SET(CMAKE_SYSTEM_PROCESSOR arm) SET(CMAKE_C_COMPILER arm-linux-gnueabihf-gcc) 3. Buildroot Buildroot is a simple and efficient embedded Linux build system. It handles everything: toolchains, root filesystems, kernel, and bootloader.\ngit clone https://github.com/buildroot/buildroot.git cd buildroot make qemu_arm_defconfig make menuconfig make 4. Yocto Project Yocto is an advanced framework for building embedded Linux distributions. Itâ€™s more complex than Buildroot but extremely flexible.\ngit clone https://git.yoctoproject.org/poky source poky/oe-init-build-env bitbake core-image-minimal Targeting ARM-based SBCs Many modern embedded Single Board Computers (SBCs), such as those using the Rockchip RK3566 Android SBC or Allwinner A64, require specific BSPs (Board Support Packages). These usually include:\nCross-toolchain U-Boot bootloader Linux kernel source Device Tree files For example, if youâ€™re working with a Rockchip RK3566 SBC, you may want to explore:\nðŸ‘‰ RK3566 Embedded Android/Linux SBC\nOr, if youâ€™re compiling generic code for your own board:\nexport CROSS_COMPILE=aarch64-linux-gnu- make ARCH=arm64 your_target_defconfig make -j$(nproc) Handling Libraries and Dependencies Cross-compiling projects that depend on shared libraries (like OpenSSL or GTK) requires special attention. Youâ€™ll often need:\nPrecompiled libraries for your target architecture Proper PKG_CONFIG_PATH and sysroot paths Environment variables like LD_LIBRARY_PATH or CMAKE_FIND_ROOT_PATH For example:\nexport PKG_CONFIG_SYSROOT_DIR=/path/to/sysroot export PKG_CONFIG_PATH=$PKG_CONFIG_SYSROOT_DIR/usr/lib/pkgconfig Debugging Cross-Compiled Applications Using QEMU You can use QEMU to emulate ARM binaries on your host PC:\nqemu-aarch64 ./mybinary Remote GDB Debugging If youâ€™re testing on the real hardware:\n# On the target: gdbserver :1234 ./mybinary # On the host: aarch64-linux-gnu-gdb ./mybinary target remote :1234 Common Pitfalls and Tips Make sure your target and host use the same endianness and ABI. Use file and readelf -h to verify binaries. Always test cross-compiled binaries on the actual hardware when possible. Keep your toolchains version-controlled and documented. Use containerized build environments for repeatability (e.g., Docker). Summary Cross-compiling Linux for embedded systems may seem complex at first, but with the right toolchain and workflow, it becomes highly efficient. Whether youâ€™re working with custom hardware, SBCs like Rockchip RK3566, or prototyping with Buildroot and Yocto, mastering cross-compilation unlocks the full power of embedded Linux development.\nThis article was prepared for developers using embedded-sbc.com to learn about embedded Linux topics. For advanced SBCs like RK3566 or PX30, refer to your vendorâ€™s SDK and prebuilt environments to save time.\nWant to dive deeper? Follow more tutorials at embedded-sbc.com or explore real-world SBC examples on our blog.\n","wordCount":"756","inLanguage":"en","datePublished":"2025-06-30T00:00:00Z","dateModified":"2025-06-30T00:00:00Z","author":{"@type":"Person","name":"Embedded SBC Team"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://embedded-sbc.com/posts/linux-cross-compilation/"},"publisher":{"@type":"Organization","name":"Embedded SBC Blog","logo":{"@type":"ImageObject","url":"https://embedded-sbc.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><img class=site-logo src=https://embedded-sbc.com/favicon-64x64.png alt="Embedded SBC Logo" style=height:32px;vertical-align:middle;margin-right:.5rem>
<a href=https://embedded-sbc.com/ accesskey=h title="Embedded SBC Blog (Alt + H)">Embedded SBC Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://embedded-sbc.com/ title=Home><span>Home</span></a></li><li><a href=https://embedded-sbc.com/about/ title="About us"><span>About us</span></a></li><li><a href=https://embedded-sbc.com/contact/ title="Contact us"><span>Contact us</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://embedded-sbc.com/>Home</a>&nbsp;Â»&nbsp;<span>Linux Cross-Compilation</span></div><h1 class="post-title entry-hint-parent">Mastering Linux Cross-Compilation for Embedded Systems</h1><div class=post-description>A comprehensive guide to cross-compiling Linux for embedded systems, covering toolchains, build systems, architecture-specific nuances, and practical examples.</div><div class=post-meta><span title='2025-06-30 00:00:00 +0000 UTC'>2025-06-30</span>&nbsp;Â·&nbsp;4 min&nbsp;Â·&nbsp;Embedded SBC Team</div></header><div class=post-content><p>Cross-compilation is an essential skill for developers working on embedded systems. Unlike standard Linux development, where code is compiled and run on the same architecture, embedded systems often use different CPU architectures (e.g., ARM, RISC-V) than your development machine (typically x86_64). This guide provides a thorough overview of how cross-compilation works, why it matters, and how to set up your own environment for building Linux for embedded systems such as <a href=/posts/sbc-overview/>ARM-based single-board computers</a> and other compact hardware platforms.</p><h2 id=what-is-cross-compilation>What is Cross-Compilation?<a hidden class=anchor aria-hidden=true href=#what-is-cross-compilation>#</a></h2><p>Cross-compilation is the process of building executable code for a target system that is different from the host system. For embedded systems, this usually means compiling code on an x86_64 PC that will run on an ARM or RISC-V device. This method is used because embedded systems often lack the resources to compile large projects locally.</p><p><strong>Key Concepts:</strong></p><ul><li><strong>Host</strong>: The system where the compilation is performed (e.g., Ubuntu x86_64)</li><li><strong>Target</strong>: The system where the compiled code will run (e.g., ARM Cortex-A SBC)</li><li><strong>Toolchain</strong>: A set of programs (compiler, linker, etc.) configured for a specific target</li></ul><h2 id=why-cross-compile-for-embedded-linux>Why Cross-Compile for Embedded Linux?<a hidden class=anchor aria-hidden=true href=#why-cross-compile-for-embedded-linux>#</a></h2><p>There are several reasons why cross-compilation is necessary:</p><ol><li><strong>Resource Constraints</strong>: Embedded boardsâ€”like those in <a href=/posts/custom-embedded-systems/>custom embedded system</a> designsâ€”typically have limited CPU and RAM, making native compilation slow or impossible.</li><li><strong>Custom Kernels</strong>: You&rsquo;ll often need to build custom Linux kernels or U-Boot versions specific to your board.</li><li><strong>Optimized Binaries</strong>: Cross-compilation allows building for performance-optimized targets using tailored compiler flags.</li></ol><h2 id=choosing-the-right-toolchain>Choosing the Right Toolchain<a hidden class=anchor aria-hidden=true href=#choosing-the-right-toolchain>#</a></h2><p>Toolchains are central to cross-compilation. You can either:</p><ul><li><strong>Download pre-built toolchains</strong> (e.g., Linaro, GCC from Arm)</li><li><strong>Build your own toolchain</strong> using crosstool-NG</li><li><strong>Use BSP-provided toolchains</strong> that come with vendor SDKs (e.g., Rockchip, Allwinner)</li></ul><p>A popular prebuilt toolchain for ARM 32-bit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt install gcc-arm-linux-gnueabihf
</span></span></code></pre></div><p>And for 64-bit ARM:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt install gcc-aarch64-linux-gnu
</span></span></code></pre></div><h2 id=anatomy-of-a-toolchain>Anatomy of a Toolchain<a hidden class=anchor aria-hidden=true href=#anatomy-of-a-toolchain>#</a></h2><p>A complete toolchain contains:</p><ul><li><strong>gcc</strong> â€“ The cross-compiler</li><li><strong>ld</strong> â€“ The linker</li><li><strong>as</strong> â€“ The assembler</li><li><strong>libc</strong> â€“ C standard library (often glibc or musl)</li><li><strong>binutils</strong> â€“ Binary utilities like objdump, strip, etc.</li></ul><h2 id=build-systems-that-support-cross-compilation>Build Systems that Support Cross-Compilation<a hidden class=anchor aria-hidden=true href=#build-systems-that-support-cross-compilation>#</a></h2><p>There are many ways to manage a cross-compilation workflow. Here are a few popular tools:</p><h3 id=1-makefiles>1. <strong>Makefiles</strong><a hidden class=anchor aria-hidden=true href=#1-makefiles>#</a></h3><p>Basic Makefiles allow cross-compiling by setting the compiler:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-make data-lang=make><span style=display:flex><span>CC<span style=color:#f92672>=</span>arm-linux-gnueabihf-gcc
</span></span><span style=display:flex><span>CFLAGS<span style=color:#f92672>+=</span>-march<span style=color:#f92672>=</span>armv7-a -mfpu<span style=color:#f92672>=</span>neon
</span></span></code></pre></div><h3 id=2-cmake>2. <strong>CMake</strong><a hidden class=anchor aria-hidden=true href=#2-cmake>#</a></h3><p>CMake supports toolchain files:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cmake -DCMAKE_TOOLCHAIN_FILE<span style=color:#f92672>=</span>toolchain-arm.cmake .
</span></span></code></pre></div><p>A basic <code>toolchain-arm.cmake</code> might look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span>SET(<span style=color:#e6db74>CMAKE_SYSTEM_NAME</span> <span style=color:#e6db74>Linux</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>SET(<span style=color:#e6db74>CMAKE_SYSTEM_PROCESSOR</span> <span style=color:#e6db74>arm</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>SET(<span style=color:#e6db74>CMAKE_C_COMPILER</span> <span style=color:#e6db74>arm-linux-gnueabihf-gcc</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=3-buildroot>3. <strong>Buildroot</strong><a hidden class=anchor aria-hidden=true href=#3-buildroot>#</a></h3><p><a href=https://buildroot.org>Buildroot</a> is a simple and efficient embedded Linux build system. It handles everything: toolchains, root filesystems, kernel, and bootloader.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/buildroot/buildroot.git
</span></span><span style=display:flex><span>cd buildroot
</span></span><span style=display:flex><span>make qemu_arm_defconfig
</span></span><span style=display:flex><span>make menuconfig
</span></span><span style=display:flex><span>make
</span></span></code></pre></div><h3 id=4-yocto-project>4. <strong>Yocto Project</strong><a hidden class=anchor aria-hidden=true href=#4-yocto-project>#</a></h3><p><a href=https://www.yoctoproject.org>Yocto</a> is an advanced framework for building embedded Linux distributions. Itâ€™s more complex than Buildroot but extremely flexible.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://git.yoctoproject.org/poky
</span></span><span style=display:flex><span>source poky/oe-init-build-env
</span></span><span style=display:flex><span>bitbake core-image-minimal
</span></span></code></pre></div><h2 id=targeting-arm-based-sbcs>Targeting ARM-based SBCs<a hidden class=anchor aria-hidden=true href=#targeting-arm-based-sbcs>#</a></h2><p>Many modern embedded Single Board Computers (SBCs), such as those using the Rockchip RK3566 <a href=/posts/android-sbc-overview/>Android SBC</a> or Allwinner A64, require specific BSPs (Board Support Packages). These usually include:</p><ul><li>Cross-toolchain</li><li>U-Boot bootloader</li><li>Linux kernel source</li><li>Device Tree files</li></ul><p>For example, if you&rsquo;re working with a Rockchip RK3566 SBC, you may want to explore:</p><p>ðŸ‘‰ <a href="https://www.producthunt.com/products/rockchip-rk3566-android-sbc-by-rocktech?launch=rockchip-rk3566-android-sbc-by-rocktech">RK3566 Embedded Android/Linux SBC</a></p><p>Or, if you&rsquo;re compiling generic code for your own board:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export CROSS_COMPILE<span style=color:#f92672>=</span>aarch64-linux-gnu-
</span></span><span style=display:flex><span>make ARCH<span style=color:#f92672>=</span>arm64 your_target_defconfig
</span></span><span style=display:flex><span>make -j<span style=color:#66d9ef>$(</span>nproc<span style=color:#66d9ef>)</span>
</span></span></code></pre></div><h2 id=handling-libraries-and-dependencies>Handling Libraries and Dependencies<a hidden class=anchor aria-hidden=true href=#handling-libraries-and-dependencies>#</a></h2><p>Cross-compiling projects that depend on shared libraries (like OpenSSL or GTK) requires special attention. Youâ€™ll often need:</p><ul><li>Precompiled libraries for your target architecture</li><li>Proper <code>PKG_CONFIG_PATH</code> and <code>sysroot</code> paths</li><li>Environment variables like <code>LD_LIBRARY_PATH</code> or <code>CMAKE_FIND_ROOT_PATH</code></li></ul><p>For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export PKG_CONFIG_SYSROOT_DIR<span style=color:#f92672>=</span>/path/to/sysroot
</span></span><span style=display:flex><span>export PKG_CONFIG_PATH<span style=color:#f92672>=</span>$PKG_CONFIG_SYSROOT_DIR/usr/lib/pkgconfig
</span></span></code></pre></div><h2 id=debugging-cross-compiled-applications>Debugging Cross-Compiled Applications<a hidden class=anchor aria-hidden=true href=#debugging-cross-compiled-applications>#</a></h2><h3 id=using-qemu>Using QEMU<a hidden class=anchor aria-hidden=true href=#using-qemu>#</a></h3><p>You can use QEMU to emulate ARM binaries on your host PC:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>qemu-aarch64 ./mybinary
</span></span></code></pre></div><h3 id=remote-gdb-debugging>Remote GDB Debugging<a hidden class=anchor aria-hidden=true href=#remote-gdb-debugging>#</a></h3><p>If youâ€™re testing on the real hardware:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># On the target:</span>
</span></span><span style=display:flex><span>gdbserver :1234 ./mybinary
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># On the host:</span>
</span></span><span style=display:flex><span>aarch64-linux-gnu-gdb ./mybinary
</span></span><span style=display:flex><span>target remote &lt;target-ip&gt;:1234
</span></span></code></pre></div><h2 id=common-pitfalls-and-tips>Common Pitfalls and Tips<a hidden class=anchor aria-hidden=true href=#common-pitfalls-and-tips>#</a></h2><ul><li>Make sure your target and host use the <strong>same endianness</strong> and <strong>ABI</strong>.</li><li>Use <code>file</code> and <code>readelf -h</code> to verify binaries.</li><li>Always test cross-compiled binaries on the actual hardware when possible.</li><li>Keep your toolchains version-controlled and documented.</li><li>Use containerized build environments for repeatability (e.g., Docker).</li></ul><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>Cross-compiling Linux for embedded systems may seem complex at first, but with the right toolchain and workflow, it becomes highly efficient. Whether you&rsquo;re working with custom hardware, SBCs like Rockchip RK3566, or prototyping with Buildroot and Yocto, mastering cross-compilation unlocks the full power of embedded Linux development.</p><p>This article was prepared for developers using <a href=https://embedded-sbc.com/>embedded-sbc.com</a> to learn about embedded Linux topics. For advanced SBCs like RK3566 or PX30, refer to your vendorâ€™s SDK and prebuilt environments to save time.</p><p>Want to dive deeper? Follow more tutorials at <a href=https://embedded-sbc.com/posts/>embedded-sbc.com</a> or explore real-world SBC examples on our blog.</p><hr></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://embedded-sbc.com/posts/android-sbc-overview/><span class=title>Â« Prev</span><br><span>Android SBC Overview</span>
</a><a class=next href=https://embedded-sbc.com/posts/the-right-linux-distro/><span class=title>Next Â»</span><br><span>The Right Linux Distro</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://embedded-sbc.com/>Embedded SBC Blog</a></span> Â·
<span>Powered by Embedded SBC Team</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>